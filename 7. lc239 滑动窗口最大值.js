/**
 * [题解] javascript  单调队列
 * 我们可以先把数组nums 的前k个元素放入滑动窗口中，可以把这个滑动窗口当作一个优先队列，滑动窗口每向右移动一步，
 * 就会有一个新的元素被添加进滑动窗口中，由于题目要求返回的是滑动窗口中的最大值，根据堆的性质特点，
 * 可以把滑动窗口中的数据看成是一个堆，也就是只要返回这个堆顶元素即可。如果在向右滑动的过程中发现这个最大值并不在滑动窗口中，
 * 那么它可能会在滑动窗口左边界的左侧，这时如果继续向右滑动窗口，那么这个最大值一定不会出现在滑动窗口中了。我们就可以把它永久的删除。
 * 我们继续移动滑动窗口，直到遇到堆顶元素出现在滑动窗口中。
 * 假定滑动窗口有两个下标 i 和 j ,其中 i 在 j 的左侧，nums[i] <= nums[j], 当滑动窗口向右移动时，只要 i  还在窗口中，那么 j 一定
 * 也会在窗口中，由于 nums[i] <= nums[j],nums[i] 一定是最小的，可以把nums[i]删除。
 * 这时我们可以使用一个队列 q 来存储还没有被移除的下标,在队列中，这些下标按照从小到大的顺序存储，并且它们在数组nums中对应的值是严格单调递减的。
 * 当滑动窗口向右移动时，就会进来一个新元素，我们拿新进来的元素与队尾的元素进行比较，如果队尾的元素小于新进来的元素，去小的留大的。
 * 就可以永久的删除队尾元素，反复对比操作，直到队列为空或者遇到比队尾元素小的新元素，循环比较结束。
 * 由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。
 * 
 * 时间复杂度为: O(n), n 为数组nums 的长度
 * 空间复杂度为：O(k), k 为 滑动窗口的长度
 * 
 *  2，3，【1，0，-3，】4，6，2
 */

var maxSlidingWindow = function(nums, k) {
    // 单调队列
    const n = nums.length;
    const q = [];
    for(let i = 0;i<k;i++){
        // q 队列中有值，并且下标 i 的值不是比最右的值大，就要删除下标为 i 的值 nums[i]
        while(q.length && nums[i] >= nums[q[q.length - 1]]){
            q.pop();
        }
        q.push(i)
    }

    const ans = [nums[q[0]]];
    for(let i = k ; i< n ;i++){
        while(q.length && nums[i] >= nums[q[q.length - 1]]){
            q.pop();
        }
        q.push(i);
        while(q[0] <= i - k){
            q.shift()
        }
        ans.push(nums[q[0]]);
    }
    return ans;
};